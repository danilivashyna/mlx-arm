#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

// Tiled matrix multiplication with shared memory
// Optimized for Adreno 740 (Snapdragon 8 Gen 2)
// Uses 16x16 tiles for better cache utilization

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer MatrixA {
    float A[];
};

layout(set = 0, binding = 1) readonly buffer MatrixB {
    float B[];
};

layout(set = 0, binding = 2) buffer MatrixC {
    float C[];
};

layout(push_constant) uniform Dimensions {
    uint M;  // Rows of A
    uint K;  // Cols of A, Rows of B
    uint N;  // Cols of B
} dims;

// Shared memory for tiling
shared float tileA[16][16];
shared float tileB[16][16];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;
    
    uint localRow = gl_LocalInvocationID.y;
    uint localCol = gl_LocalInvocationID.x;
    
    float sum = 0.0;
    
    // Number of tiles needed
    uint numTiles = (dims.K + 15) / 16;
    
    for (uint t = 0; t < numTiles; t++) {
        // Load tile from A
        uint aRow = row;
        uint aCol = t * 16 + localCol;
        if (aRow < dims.M && aCol < dims.K) {
            tileA[localRow][localCol] = A[aRow * dims.K + aCol];
        } else {
            tileA[localRow][localCol] = 0.0;
        }
        
        // Load tile from B
        uint bRow = t * 16 + localRow;
        uint bCol = col;
        if (bRow < dims.K && bCol < dims.N) {
            tileB[localRow][localCol] = B[bRow * dims.N + bCol];
        } else {
            tileB[localRow][localCol] = 0.0;
        }
        
        // Synchronize to ensure tiles are loaded
        barrier();
        
        // Compute partial dot product for this tile
        for (uint k = 0; k < 16; k++) {
            sum += tileA[localRow][k] * tileB[k][localCol];
        }
        
        // Synchronize before loading next tile
        barrier();
    }
    
    // Write result
    if (row < dims.M && col < dims.N) {
        C[row * dims.N + col] = sum;
    }
}
